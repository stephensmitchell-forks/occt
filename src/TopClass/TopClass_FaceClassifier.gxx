// Created on: 1992-11-18
// Created by: Remi LEQUETTE
// Copyright (c) 1992-1999 Matra Datavision
// Copyright (c) 1999-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

//  Modified by skv - Thu Jul 13 18:00:34 2006 OCC12627
// The method Perform is totally rewroted.

#include <algorithm>

#include <NCollection_Array1.hxx>
#include <TopClass_RayInfo.hxx>

//=======================================================================
//function : TopClass_FaceClassifier
//purpose  : 
//=======================================================================
TopClass_FaceClassifier::TopClass_FaceClassifier() :
myEdgeParameter(0.0),
nowires(Standard_True),
myState(TopAbs_UNKNOWN)
{
}

//=======================================================================
//function : TopClass_FaceClassifier
//purpose  : 
//=======================================================================
TopClass_FaceClassifier::TopClass_FaceClassifier(TheFaceExplorer& FExp,
                                                 const gp_Pnt2d& P,
                                                 const Standard_Real theTol) :
myEdgeParameter(0.0),
nowires(Standard_True),
myState(TopAbs_UNKNOWN)
{
  Perform(FExp, P, theTol);
}

//=======================================================================
//function : Perform
//purpose  : 
//=======================================================================
void TopClass_FaceClassifier::Perform(TheFaceExplorer& Fexp,
                                      const gp_Pnt2d& P,
                                      const Standard_Real theTol)
{
  gp_Pnt2d aPoint(P);
  Standard_Boolean aResOfPointCheck = Standard_False;
  while (aResOfPointCheck == Standard_False)
  {
    aResOfPointCheck = Fexp.CheckPoint(aPoint);
  }

  TopClass_GeomEdge          anEdge;

  Standard_Integer           aClosestInd;
  IntRes2d_IntersectionPoint aPInter;
  TopClass_FClass2d aClassifier;
  NCollection_List<TopClass_RayInfo> aSegmentList;
  Fexp.ListOfRays(aPoint, aSegmentList);
  
  NCollection_Array1<TopClass_RayInfo> aSegmArr(0, Max(aSegmentList.Extent() - 1, 0));

  {
    NCollection_List<TopClass_RayInfo>::Iterator aSegmItr(aSegmentList);
    for (Standard_Integer i = 0; aSegmItr.More(); i++, aSegmItr.Next())
    {
      aSegmArr(i) = aSegmItr.Value();
    }
  }

  std::sort(aSegmArr.begin(), aSegmArr.end());

  //These two constants are entered in order to speeding up the performance.
  unsigned int aRealWeight = UINT_MAX;
  Standard_Real aMaxDelta = -1.0;

  nowires = Standard_True;

  for (Standard_Integer aVecIdx = 0; aVecIdx < aSegmArr.Size(); aVecIdx++)
  {
    TopClass_RayInfo &aRayInfo = aSegmArr(aVecIdx);

    aRealWeight = aRayInfo.GetWeight();
    aClassifier.Reset(aRayInfo.GetLine(), aRayInfo.GetParameter(), theTol);

    for (Fexp.InitWires(); Fexp.MoreWires(); Fexp.NextWire())
    {
      nowires = Standard_False;
      // test this wire
      for (Fexp.InitEdges(); Fexp.MoreEdges(); Fexp.NextEdge())
      {
        // test this edge
        Fexp.CurrentEdge(anEdge);

        if (aMaxDelta < 0.0)
        {
          const GeomAdaptor_Surface &anAS = anEdge.GetSurface();
          aMaxDelta = Max(0.01, 100.0*Min(anAS.UResolution(theTol),
                                          anAS.VResolution(theTol)));
        }

        if ((anEdge.GetOrientation() != TopAbs_FORWARD) &&
            (anEdge.GetOrientation() != TopAbs_REVERSED))
        {
          continue;
        }

        //Intersects with anEdge
        aClassifier.Compare(anEdge);
        aClosestInd = aClassifier.ClosestIntersection();

        if (aClosestInd != 0)
        {
          // save the closest edge
          TheIntersection2d &anIntersector = aClassifier.Intersector();
          Standard_Integer  aNbPnts = anIntersector.NbPoints();

          myEdge = anEdge;

          if (aClosestInd <= aNbPnts)
          {
            aPInter = anIntersector.Point(aClosestInd);
          }
          else
          {
            aClosestInd -= aNbPnts;

            //Tangential case
            aRayInfo.AddPenalty(2);

            if (aClosestInd & 1) {
              aPInter = anIntersector.
                Segment((aClosestInd + 1) / 2).FirstPoint();
            }
            else
            {
              aPInter = anIntersector.
                Segment((aClosestInd + 1) / 2).LastPoint();
            }
          }

          const gp_Pnt2d &aPOnC = aPInter.Value();
          if (Fexp.IsPointInEdgeVertex(aPOnC))
          {
            aRayInfo.AddPenalty(5);
          }

          aRayInfo.AddParamOnLine(aPInter.ParamOnFirst());

          myPosition = aPInter.
            TransitionOfSecond().PositionOnCurve();
          myEdgeParameter = aPInter.ParamOnSecond();
        }
        
        if (aClassifier.State() == TopAbs_ON)
        {
          // if we are ON, we stop
          myState = TopAbs_ON;
          return;
        }
      }

      aRayInfo.SetState(aClassifier.State());

      if (aRayInfo.GetState() == TopAbs_OUT)
      {
        // If we are out of the wire we stop.
        // But let us check if we can trust this result.
        if ((aRayInfo.GetWeight() == aRealWeight) &&
            (aRayInfo.MinDeltaInterval() > aMaxDelta))
        {
          myState = TopAbs_OUT;
          return;
        }
      }
    }

    myState = aClassifier.State();
    if (!aClassifier.IsHeadOrEnd() && (myState != TopAbs_UNKNOWN))
    {
      // Check if we can trust this result.
      if ((aRayInfo.GetWeight() == aRealWeight) &&
          (aRayInfo.MinDeltaInterval() > aMaxDelta))
      {
        return;
      }
    }
  }

  if (nowires)
  {
    myState = TopAbs_IN;
    return;
  }

  std::sort(aSegmArr.begin(), aSegmArr.end());

  myState = aSegmArr(0).GetState();
  Standard_Integer aPrevWeight = aSegmArr(0).GetWeight();
  aMaxDelta = RealFirst();

  for (Standard_Integer aVecIdx = 0; aVecIdx < aSegmArr.Size(); aVecIdx++)
  {
    const TopClass_RayInfo &aRI = aSegmArr(aVecIdx);

    if (aRI.GetState() == TopAbs_UNKNOWN)
    {
      continue;
    }

    Standard_Integer aCurrWeight = aRI.GetWeight();

    if (aCurrWeight != aPrevWeight)
      break;

    const Standard_Real aMinDelta = aRI.MinDeltaInterval();

    if (aMinDelta < aMaxDelta)
    {
      //We are looking for the segment,
      //which has maximal delta.
      continue;
    }

    aMaxDelta = aMinDelta;
    myState = aRI.GetState();
  }
}

//=======================================================================
//function : State
//purpose  : 
//=======================================================================

TopAbs_State TopClass_FaceClassifier::State() const
{
  return myState;
}

//=======================================================================
//function : Edge
//purpose  : 
//=======================================================================

const TopClass_GeomEdge& TopClass_FaceClassifier::Edge() const
{
  return myEdge;
}

//=======================================================================
//function : EdgeParameter
//purpose  : 
//=======================================================================

Standard_Real TopClass_FaceClassifier::EdgeParameter() const
{
  return myEdgeParameter;
}

