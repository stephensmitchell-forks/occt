// Created on: 1992-11-18
// Created by: Remi LEQUETTE
// Copyright (c) 1992-1999 Matra Datavision
// Copyright (c) 1999-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

//  Modified by skv - Thu Jul 13 18:00:34 2006 OCC12627
// The method Perform is totally rewroted.

#include <algorithm>

#include <NCollection_Array1.hxx>
#include <TopClass_RayInfo.hxx>

//=======================================================================
//function : TopClass_FaceClassifier
//purpose  : 
//=======================================================================
TopClass_FaceClassifier::TopClass_FaceClassifier() :
myEdgeParameter(0.0),
myState(TopAbs_UNKNOWN)
{
}

//=======================================================================
//function : TopClass_FaceClassifier
//purpose  : 
//=======================================================================
TopClass_FaceClassifier::TopClass_FaceClassifier(TheFaceExplorer& FExp,
                                                 const gp_Pnt2d& P,
                                                 const Standard_Real theTol) :
myEdgeParameter(0.0),
myState(TopAbs_UNKNOWN)
{
  Perform(FExp, P, theTol);
}

//=======================================================================
//function : Perform
//purpose  : 
//=======================================================================
void TopClass_FaceClassifier::Perform(TheFaceExplorer& theFExp,
                                      const gp_Pnt2d& theP,
                                      const Standard_Real theTol)
{
  myEdge = TopClass_GeomEdge();
  myEdgeParameter = 0.0;
  myState = TopAbs_UNKNOWN;

  gp_Pnt2d aPoint(theP);
  Standard_Boolean aResOfPointCheck = Standard_False;
  while (aResOfPointCheck == Standard_False)
  {
    aResOfPointCheck = theFExp.CheckPoint(aPoint);
  }

  TopClass_GeomEdge          anEdge;

  Standard_Integer           aClosestInd;
  IntRes2d_IntersectionPoint aPInter;
  TopClass_FClass2d aClassifier;

  //These two constants are entered in order to speeding up the performance.
  unsigned int aMaxWeight = UINT_MAX;
  Standard_Real aMaxDelta = -1.0;

  Standard_Boolean hasWires = Standard_False;
  TopClass_RayInfo aRayInfo;

  theFExp.FirstRay(aPoint, aRayInfo);
  Standard_Real aRealInterval = aRayInfo.MinDeltaInterval();

  do
  {
    aClassifier.Reset(aRayInfo.GetLine(), aRayInfo.GetParameter(), theTol);

    for (theFExp.InitWires(); theFExp.MoreWires(); theFExp.NextWire())
    {
      // Counts penalties added by TheFaceExplorer::IsPointInEdgeVertex(...) method
      unsigned int aSumPenaltyVertCoinc = 0;

      // test this wire
      for (theFExp.InitEdges(); theFExp.MoreEdges(); theFExp.NextEdge())
      {
        // Empty face is possible:
        //    plane pl 0 0 0 0 0 1
        //    mkface ff pl
        // As result, ff does not contain any wires/edges/vertices.
        // However, Geom2dHatch_Classifier (which is used by DBRep_IsoBuilder)
        // returns some wire but does not find any edge. Therefore, "hasWires"
        // flag should be put to the current "edges"-cycle (not outer "wires"-cycle).
        hasWires = Standard_True;
        
        // test this edge
        theFExp.CurrentEdge(anEdge);

        if (aMaxDelta < 0.0)
        {
          const GeomAdaptor_Surface &anAS = anEdge.GetSurface();
          aMaxDelta = Max(0.01, 100.0*Min(anAS.UResolution(theTol),
                                          anAS.VResolution(theTol)));
        }

        if ((anEdge.GetOrientation() != TopAbs_FORWARD) &&
            (anEdge.GetOrientation() != TopAbs_REVERSED))
        {
          continue;
        }

        //Intersects with anEdge
        aClassifier.Compare(anEdge);
        aClosestInd = aClassifier.ClosestIntersection();

        if (aClosestInd != 0)
        {
          // save the closest edge
          TheIntersection2d &anIntersector = aClassifier.Intersector();
          Standard_Integer  aNbPnts = anIntersector.NbPoints();

          myEdge = anEdge;

          if (aClosestInd <= aNbPnts)
          {
            aPInter = anIntersector.Point(aClosestInd);
          }
          else
          {
            aClosestInd -= aNbPnts;

            //Tangential case
            aRayInfo.AddPenalty(2);

            if (aClosestInd & 1) {
              aPInter = anIntersector.
                Segment((aClosestInd + 1) / 2).FirstPoint();
            }
            else
            {
              aPInter = anIntersector.
                Segment((aClosestInd + 1) / 2).LastPoint();
            }
          }

          const gp_Pnt2d &aPOnC = aPInter.Value();
          if (theFExp.IsPointInEdgeVertex(aPOnC))
          {
            const unsigned int aPenaltyVal = 5u;
            aSumPenaltyVertCoinc += aPenaltyVal;
            aRayInfo.AddPenalty(aPenaltyVal);
          }

          aRayInfo.AddParamOnLine(aPInter.ParamOnFirst());

          myEdgeParameter = aPInter.ParamOnSecond();
        }
        
        if ((aClassifier.State() == TopAbs_ON) &&
            (aRayInfo.GetWeight() == aSumPenaltyVertCoinc))
        {
          // if we are ON, we stop. In case only if we can trust this info.
          // In case of ON-status we can trust the ray going through the edge vertex.
          myState = TopAbs_ON;
          return;
        }
      }

      if (aRayInfo.MinDeltaInterval() < aMaxDelta)
      {
        aRayInfo.AddPenalty();
      }

      aRayInfo.SetState(aClassifier.State());

      if ((aRayInfo.GetState() == TopAbs_OUT) && (aRayInfo.GetWeight() == 0))
      {
        // If we are out of the wire we stop. In case only if we can trust this info.
        myState = TopAbs_OUT;
        return;
      }
    }

    if ((aClassifier.State() != TopAbs_UNKNOWN) && ((myState == TopAbs_UNKNOWN) ||
                                                    (aRayInfo.GetWeight() <= aMaxWeight)))
    {
      if (aRayInfo.GetWeight() < aMaxWeight)
      {
        aMaxWeight = aRayInfo.GetWeight();
        aRealInterval = aRayInfo.MinDeltaInterval();
        myState = aClassifier.State();
      }
      else if (aRayInfo.MinDeltaInterval() >= aRealInterval)
      {
        myState = aClassifier.State();
        aRealInterval = aRayInfo.MinDeltaInterval();
      }
      else if (myState == TopAbs_UNKNOWN)
      {
        myState = aClassifier.State();
      }
      
      if (!aClassifier.IsHeadOrEnd() && (aRayInfo.GetWeight() == 0))
      {
        myState = aClassifier.State();
        return;
      }
    }
  }
  while (hasWires && 
         ((aRayInfo.GetWeight() != 0) || (myState == TopAbs_UNKNOWN)) &&
         theFExp.OtherRay(aPoint, aRayInfo, aMaxWeight));

  if (!hasWires)
  {
    myState = TopAbs_IN;
    return;
  }
}

//=======================================================================
//function : State
//purpose  : 
//=======================================================================

TopAbs_State TopClass_FaceClassifier::State() const
{
  return myState;
}

